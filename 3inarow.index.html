<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>–õ–∞–±–∏—Ä–∏–Ω—Ç –ö–æ–Ω—Ñ–µ—Ç</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #fafafa;
      font-family: 'Segoe UI', system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
    }

    #app {
      width: 100%;
      max-width: 420px;
    }

    .screen { display: none; }
    .screen.active { display: block; }

    /* ========== –ö–ê–†–¢–ê –£–†–û–í–ù–ï–ô (–ó–ú–ï–ô–ö–ê) ========== */
    #map-screen {
      text-align: center;
    }

    #map-screen h1 {
      color: #d62828;
      margin-bottom: 20px;
      font-size: 24px;
    }

    #maze-path {
      position: relative;
      height: 300px;
      background: #f9f9f9;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    .level-node {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: white;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .level-node:hover {
      transform: scale(1.1);
    }

    .level-node.locked {
      background: #ccc;
      cursor: not-allowed;
    }

    .level-node.unlocked {
      background: #4caf50;
    }

    .level-node.current {
      background: #e63946;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(230, 57, 70, 0); }
      100% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0); }
    }

    /* ========== –ò–ì–†–ê ========== */
    #game-ui {
      display: flex;
      justify-content: space-between;
      color: #d62828;
      font-weight: bold;
      margin-bottom: 12px;
      font-size: 16px;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      background: #f0f0f0;
      padding: 4px;
      border-radius: 10px;
      aspect-ratio: 1 / 1;
      width: 100%;
    }

    .cell {
      background: white;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      cursor: pointer;
      transition: transform 0.12s;
    }

    .cell.obstacle {
      background: #555;
      color: white;
    }

    .cell.selected {
      transform: scale(0.9);
      box-shadow: 0 0 0 3px #e63946;
    }

    /* ========== –≠–ö–†–ê–ù –ü–û–ë–ï–î–´ ========== */
    #win-screen {
      text-align: center;
      padding: 20px;
    }

    #win-screen h2 {
      color: #2e7d32;
      margin-bottom: 16px;
      font-size: 22px;
    }

    .stars {
      font-size: 28px;
      margin: 10px 0;
      color: gold;
    }

    .btn {
      display: block;
      width: 100%;
      padding: 12px;
      margin: 12px 0;
      border: none;
      border-radius: 30px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
    }

    .btn-next {
      background: #4caf50;
      color: white;
    }

    .btn-map {
      background: #e63946;
      color: white;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- –≠–ö–†–ê–ù –ö–ê–†–¢–´ (–ó–ú–ï–ô–ö–ê) -->
    <div id="map-screen" class="screen active">
      <h1>üß≠ –õ–∞–±–∏—Ä–∏–Ω—Ç –ö–æ–Ω—Ñ–µ—Ç</h1>
      <div id="maze-path"></div>
    </div>

    <!-- –ò–ì–†–ê -->
    <div id="game-screen" class="screen">
      <div id="game-ui">
        <div>–°–æ–±—Ä–∞–Ω–æ: <span id="collected">0</span>/<span id="target">30</span></div>
        <div>–•–æ–¥—ã: <span id="moves">30</span></div>
        <div>–£—Ä: <span id="level-num">1</span></div>
      </div>
      <div id="game-board"></div>
    </div>

    <!-- –ü–û–ë–ï–î–ê -->
    <div id="win-screen" class="screen">
      <h2>üéâ –£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
      <div class="stars">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div>
      <p>+5 –∑–≤—ë–∑–¥ –∑–∞ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ!</p>
      <button class="btn btn-next" id="btn-next">‚ñ∂ –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
      <button class="btn btn-map" id="btn-map">üó∫Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –∫–∞—Ä—Ç—É</button>
    </div>
  </div>

  <script>
    // ====== –ù–ê–°–¢–†–û–ô–ö–ò ======
    const CANDIES = ['üç≠', 'üç¨', 'üç´', 'üç©', 'üç™', 'üßÅ', 'üçé', 'üçá'];
    const TARGETS = [30, 40, 55, 70, 90, 110, 135, 160, 190, 220]; // –∫–æ–Ω—Ñ–µ—Ç –¥–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è
    const BASE_MOVES = 32;
    const BOARD_SIZE = 8;
    const TOTAL_LEVELS = 10;

    // ====== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ======
    let currentLevel = 1;
    let collected = 0;
    let movesLeft = BASE_MOVES;
    let selectedCell = null;
    let gameActive = true;
    let unlockedLevels = JSON.parse(localStorage.getItem('unlockedLevels')) || [1];

    // ====== DOM ======
    const mazePath = document.getElementById('maze-path');
    const gameBoardEl = document.getElementById('game-board');
    const collectedEl = document.getElementById('collected');
    const targetEl = document.getElementById('target');
    const movesEl = document.getElementById('moves');
    const levelNumEl = document.getElementById('level-num');
    const btnNext = document.getElementById('btn-next');
    const btnMap = document.getElementById('btn-map');

    // ====== –ö–ê–†–¢–ê –£–†–û–í–ù–ï–ô (–ó–ú–ï–ô–ö–ê) ======
    function drawMazeMap() {
      mazePath.innerHTML = '';
      const rows = 3;
      const cols = 4;
      const spacingX = (mazePath.offsetWidth - 60) / (cols - 1);
      const spacingY = (mazePath.offsetHeight - 60) / (rows - 1);

      let levelIndex = 1;
      for (let row = 0; row < rows; row++) {
        const isReversed = row % 2 === 1; // –∑–º–µ–π–∫–∞
        const colsInRow = Math.min(TOTAL_LEVELS - (row * cols), cols);
        for (let i = 0; i < colsInRow; i++) {
          const col = isReversed ? cols - 1 - i : i;
          const x = 30 + col * spacingX;
          const y = 30 + row * spacingY;

          const node = document.createElement('div');
          node.className = 'level-node';
          node.textContent = levelIndex;

          if (levelIndex > Math.max(...unlockedLevels)) {
            node.classList.add('locked');
          } else if (levelIndex === currentLevel) {
            node.classList.add('current');
          } else {
            node.classList.add('unlocked');
          }

          if (!node.classList.contains('locked')) {
            node.addEventListener('click', () => startLevel(levelIndex));
          }

          node.style.left = (x - 22) + 'px';
          node.style.top = (y - 22) + 'px';
          mazePath.appendChild(node);

          levelIndex++;
          if (levelIndex > TOTAL_LEVELS) break;
        }
        if (levelIndex > TOTAL_LEVELS) break;
      }
    }

    // ====== –ó–ê–ü–£–°–ö –£–†–û–í–ù–Ø ======
    function startLevel(level) {
      currentLevel = level;
      const target = TARGETS[Math.min(level - 1, TARGETS.length - 1)];
      collected = 0;
      movesLeft = Math.max(12, BASE_MOVES - (level - 1) * 2);

      collectedEl.textContent = '0';
      targetEl.textContent = target;
      movesEl.textContent = movesLeft;
      levelNumEl.textContent = level;

      initGameBoard();
      showScreen('game-screen');
    }

    // ====== –ò–ì–†–û–í–û–ï –ü–û–õ–ï ======
    function initGameBoard() {
      window.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));

      // –ö–∞–º–Ω–∏ —Å 5 —É—Ä–æ–≤–Ω—è
      if (currentLevel >= 5) {
        const stoneCount = 4 + (currentLevel - 5) * 2;
        const positions = [];
        for (let y = 1; y < BOARD_SIZE - 1; y += 2) {
          for (let x = 1; x < BOARD_SIZE - 1; x += 2) {
            if (positions.length < stoneCount) positions.push([x, y]);
          }
        }
        for (let i = 0; i < Math.min(stoneCount, positions.length); i++) {
          const [x, y] = positions[i];
          window.board[y][x] = 'ü™®';
        }
      }

      // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–æ–Ω—Ñ–µ—Ç–∞–º–∏
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (window.board[y][x] === null) {
            window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
          }
        }
      }

      renderBoard();
    }

    function renderBoard() {
      gameBoardEl.innerHTML = '';
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (window.board[y][x] === 'ü™®') {
            cell.classList.add('obstacle');
            cell.textContent = 'ü™®';
          } else {
            cell.textContent = window.board[y][x];
          }
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleCellClick);
          gameBoardEl.appendChild(cell);
        }
      }
    }

    function handleCellClick(e) {
      if (!gameActive) return;
      const x = parseInt(e.target.dataset.x);
      const y = parseInt(e.target.dataset.y);
      if (window.board[y][x] === 'ü™®') return;

      if (selectedCell === null) {
        selectedCell = { x, y };
        e.target.classList.add('selected');
      } else {
        const { x: x1, y: y1 } = selectedCell;
        document.querySelector(`.cell[data-x="${x1}"][data-y="${y1}"]`)?.classList.remove('selected');

        const dx = Math.abs(x - x1);
        const dy = Math.abs(y - y1);
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
          // –û–±–º–µ–Ω
          [window.board[y][x], window.board[y1][x1]] = [window.board[y1][x1], window.board[y][x]];
          renderBoard();

          if (hasMatches()) {
            movesLeft--;
            movesEl.textContent = movesLeft;
            setTimeout(processTurn, 300);
            selectedCell = null;
            return;
          }

          // –û—Ç–∫–∞—Ç
          [window.board[y][x], window.board[y1][x1]] = [window.board[y1][x1], window.board[y][x]];
          renderBoard();
        }
        selectedCell = null;
      }

      if (movesLeft <= 0) {
        alert('–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å! –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.');
        showScreen('map-screen');
        drawMazeMap();
      }
    }

    function hasMatches() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE - 2; x++) {
          if (window.board[y][x] !== 'ü™®' && 
              window.board[y][x] === window.board[y][x+1] && 
              window.board[y][x] === window.board[y][x+2]) {
            return true;
          }
        }
      }
      for (let x = 0; x < BOARD_SIZE; x++) {
        for (let y = 0; y < BOARD_SIZE - 2; y++) {
          if (window.board[y][x] !== 'ü™®' && 
              window.board[y][x] === window.board[y+1][x] && 
              window.board[y][x] === window.board[y+2][x]) {
            return true;
          }
        }
      }
      return false;
    }

    function processTurn() {
      let removed = 0;
      const toRemove = new Set();

      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE - 2; x++) {
          if (window.board[y][x] !== 'ü™®' && 
              window.board[y][x] === window.board[y][x+1] && 
              window.board[y][x] === window.board[y][x+2]) {
            let end = x + 2;
            while (end + 1 < BOARD_SIZE && window.board[y][end + 1] === window.board[y][x]) end++;
            for (let i = x; i <= end; i++) toRemove.add(`${x},${y}`);
            x = end;
          }
        }
      }

      // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
      for (let x = 0; x < BOARD_SIZE; x++) {
        for (let y = 0; y < BOARD_SIZE - 2; y++) {
          if (window.board[y][x] !== 'ü™®' && 
              window.board[y][x] === window.board[y+1][x] && 
              window.board[y][x] === window.board[y+2][x]) {
            let end = y + 2;
            while (end + 1 < BOARD_SIZE && window.board[end + 1][x] === window.board[y][x]) end++;
            for (let i = y; i <= end; i++) toRemove.add(`${x},${y}`);
            y = end;
          }
        }
      }

      toRemove.forEach(pos => {
        const [x, y] = pos.split(',').map(Number);
        if (window.board[y][x] !== 'ü™®') {
          window.board[y][x] = null;
          removed++;
        }
      });

      collected += removed;
      collectedEl.textContent = collected;
      const target = TARGETS[Math.min(currentLevel - 1, TARGETS.length - 1)];
      if (collected >= target) {
        completeLevel();
        return;
      }

      // –ü–∞–¥–µ–Ω–∏–µ
      for (let x = 0; x < BOARD_SIZE; x++) {
        let writeY = BOARD_SIZE - 1;
        for (let y = BOARD_SIZE - 1; y >= 0; y--) {
          if (window.board[y][x] !== null && window.board[y][x] !== 'ü™®') {
            if (writeY !== y) {
              window.board[writeY][x] = window.board[y][x];
              window.board[y][x] = null;
            }
            writeY--;
          }
        }
        for (let y = writeY; y >= 0; y--) {
          if (window.board[y][x] === null) {
            window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
          }
        }
      }

      renderBoard();
      if (hasMatches()) {
        setTimeout(processTurn, 300);
      }
    }

    function completeLevel() {
      gameActive = false;
      if (currentLevel + 1 <= TOTAL_LEVELS && !unlockedLevels.includes(currentLevel + 1)) {
        unlockedLevels.push(currentLevel + 1);
        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels));
      }
      showScreen('win-screen');
    }

    // ====== –ù–ê–í–ò–ì–ê–¶–ò–Ø ======
    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    btnNext.addEventListener('click', () => {
      if (currentLevel < TOTAL_LEVELS) {
        startLevel(currentLevel + 1);
      } else {
        alert('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø—Ä–æ—à–ª–∏ –≤–µ—Å—å –ª–∞–±–∏—Ä–∏–Ω—Ç!');
        showScreen('map-screen');
        drawMazeMap();
      }
    });

    btnMap.addEventListener('click', () => {
      showScreen('map-screen');
      drawMazeMap();
    });

    // ====== –°–¢–ê–†–¢ ======
    drawMazeMap();
  </script>
</body>
</html>
