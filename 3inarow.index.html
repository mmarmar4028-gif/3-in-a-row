<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>–õ–∞–±–∏—Ä–∏–Ω—Ç –ö–æ–Ω—Ñ–µ—Ç</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #fafafa;
      font-family: 'Segoe UI', system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
    }

    #app {
      width: 100%;
      max-width: 420px;
    }

    .screen { display: none; }
    .screen.active { display: block; }

    /* ========== –ö–ê–†–¢–ê –£–†–û–í–ù–ï–ô (–ó–ú–ï–ô–ö–ê) ========== */
    #map-screen {
      text-align: center;
    }

    #map-screen h1 {
      color: #d62828;
      margin-bottom: 20px;
      font-size: 24px;
    }

    #maze-path {
      position: relative;
      height: 300px;
      background: #f9f9f9;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    .level-node {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: white;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transition: transform 0.2s;
    }

    .level-node:hover:not(.locked) {
      transform: scale(1.1);
    }

    .level-node.locked { background: #ccc; cursor: not-allowed; }
    .level-node.unlocked { background: #4caf50; }
    .level-node.current { background: #e63946; }

    /* ========== –ò–ì–†–ê ========== */
    #game-ui {
      display: flex;
      justify-content: space-between;
      color: #d62828;
      font-weight: bold;
      margin-bottom: 12px;
      font-size: 16px;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      background: #f0f0f0;
      padding: 4px;
      border-radius: 10px;
      aspect-ratio: 1 / 1;
      width: 100%;
    }

    .cell {
      background: white;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      cursor: pointer;
      transition: transform 0.12s;
    }

    .cell.obstacle {
      background: #555;
      color: white;
    }

    .cell.selected {
      transform: scale(0.9);
      box-shadow: 0 0 0 3px #e63946;
    }

    #restart-btn {
      margin-top: 12px;
      width: 100%;
      padding: 10px;
      background: #e63946;
      color: white;
      border: none;
      border-radius: 30px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(230, 57, 70, 0.4);
    }

    /* ========== –≠–ö–†–ê–ù –ü–û–ë–ï–î–´ ========== */
    #win-screen {
      text-align: center;
      padding: 20px;
    }

    #win-screen h2 {
      color: #2e7d32;
      margin-bottom: 16px;
      font-size: 22px;
    }

    .stars {
      font-size: 28px;
      margin: 10px 0;
      color: gold;
    }

    .btn {
      display: block;
      width: 100%;
      padding: 12px;
      margin: 12px 0;
      border: none;
      border-radius: 30px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
    }

    .btn-next { background: #4caf50; color: white; }
    .btn-map { background: #e63946; color: white; }
  </style>
</head>
<body>
  <div id="app">
    <!-- –ö–ê–†–¢–ê -->
    <div id="map-screen" class="screen active">
      <h1>üß≠ –õ–∞–±–∏—Ä–∏–Ω—Ç –ö–æ–Ω—Ñ–µ—Ç</h1>
      <div id="maze-path"></div>
    </div>

    <!-- –ò–ì–†–ê -->
    <div id="game-screen" class="screen">
      <div id="game-ui">
        <div>–°–æ–±—Ä–∞–Ω–æ: <span id="collected">0</span>/<span id="target">30</span></div>
        <div>–•–æ–¥—ã: <span id="moves">45</span></div>
        <div>–£—Ä: <span id="level-num">1</span></div>
      </div>
      <div id="game-board"></div>
      <button id="restart-btn">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>

    <!-- –ü–û–ë–ï–î–ê -->
    <div id="win-screen" class="screen">
      <h2>üéâ –£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
      <div class="stars">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div>
      <p>+5 –∑–≤—ë–∑–¥ –∑–∞ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ!</p>
      <button class="btn btn-next" id="btn-next">‚ñ∂ –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
      <button class="btn btn-map" id="btn-map">üó∫Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –∫–∞—Ä—Ç—É</button>
    </div>
  </div>

  <script>
    // ====== –ù–ê–°–¢–†–û–ô–ö–ò ======
    const CANDIES = ['üç≠', 'üç¨', 'üç´', 'üç©', 'üç™', 'üßÅ'];
    const TARGETS = [30, 45, 60, 75, 90, 105, 120, 135, 150, 165]; // –Ω—É–∂–Ω–æ —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å
    const MOVES_PER_LEVEL = 45; // –≤—Å–µ–≥–¥–∞ 45 —Ö–æ–¥–æ–≤
    const BOARD_SIZE = 8;
    const TOTAL_LEVELS = 10;

    // ====== –ì–õ–û–ë–ê–õ–¨–ù–´–ï ======
    let currentLevel = 1;
    let collected = 0;
    let movesLeft = MOVES_PER_LEVEL;
    let selectedCell = null;
    let gameActive = true;
    let unlockedLevels = JSON.parse(localStorage.getItem('unlockedLevels')) || [1];

    // ====== DOM ======
    const mazePath = document.getElementById('maze-path');
    const gameBoardEl = document.getElementById('game-board');
    const collectedEl = document.getElementById('collected');
    const targetEl = document.getElementById('target');
    const movesEl = document.getElementById('moves');
    const levelNumEl = document.getElementById('level-num');
    const restartBtn = document.getElementById('restart-btn');
    const btnNext = document.getElementById('btn-next');
    const btnMap = document.getElementById('btn-map');

    // ====== –ö–ê–†–¢–ê –ó–ú–ï–ô–ö–ê ======
    function drawMazeMap() {
      mazePath.innerHTML = '';
      const rows = 3;
      const cols = 4;
      const w = mazePath.clientWidth;
      const h = mazePath.clientHeight;
      const dx = (w - 60) / (cols - 1);
      const dy = (h - 60) / (rows - 1);

      let level = 1;
      for (let r = 0; r < rows; r++) {
        const dir = r % 2 === 0 ? 1 : -1;
        const start = r % 2 === 0 ? 0 : cols - 1;
        const end = r % 2 === 0 ? cols : -1;
        for (let c = start; c !== end; c += dir) {
          if (level > TOTAL_LEVELS) break;
          const x = 30 + (r % 2 === 0 ? c : cols - 1 - c) * dx;
          const y = 30 + r * dy;

          const node = document.createElement('div');
          node.className = `level-node ${level <= Math.max(...unlockedLevels) ? (level === currentLevel ? 'current' : 'unlocked') : 'locked'}`;
          node.textContent = level;
          if (!node.classList.contains('locked')) {
            node.onclick = () => startLevel(level);
          }
          node.style.left = (x - 22) + 'px';
          node.style.top = (y - 22) + 'px';
          mazePath.appendChild(node);
          level++;
        }
        if (level > TOTAL_LEVELS) break;
      }
    }

    // ====== –ò–ì–†–ê ======
    function startLevel(level) {
      currentLevel = level;
      const target = TARGETS[level - 1] || TARGETS[TARGETS.length - 1];
      collected = 0;
      movesLeft = MOVES_PER_LEVEL;

      collectedEl.textContent = '0';
      targetEl.textContent = target;
      movesEl.textContent = movesLeft;
      levelNumEl.textContent = level;

      initBoard();
      showScreen('game-screen');
    }

    function initBoard() {
      window.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));

      // –ö–∞–º–Ω–∏ —Å 5 —É—Ä–æ–≤–Ω—è
      if (currentLevel >= 5) {
        const count = 2 * (currentLevel - 4); // 2, 4, 6...
        const positions = [];
        for (let y = 1; y < BOARD_SIZE - 1; y += 2) {
          for (let x = 1; x < BOARD_SIZE - 1; x += 2) {
            if (positions.length < count) positions.push([x, y]);
          }
        }
        for (const [x, y] of positions) {
          window.board[y][x] = 'ü™®';
        }
      }

      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (window.board[y][x] !== 'ü™®') {
            window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
          }
        }
      }

      // –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
      while (hasMatches()) {
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (window.board[y][x] !== 'ü™®') {
              window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
            }
          }
        }
      }

      renderBoard();
    }

    function renderBoard() {
      gameBoardEl.innerHTML = '';
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (window.board[y][x] === 'ü™®') {
            cell.classList.add('obstacle');
            cell.textContent = 'ü™®';
          } else {
            cell.textContent = window.board[y][x];
          }
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleCellClick);
          gameBoardEl.appendChild(cell);
        }
      }
    }

    function handleCellClick(e) {
      if (!gameActive) return;
      const x = +e.target.dataset.x;
      const y = +e.target.dataset.y;
      if (window.board[y][x] === 'ü™®') return;

      if (selectedCell === null) {
        selectedCell = { x, y };
        e.target.classList.add('selected');
      } else {
        const { x: x1, y: y1 } = selectedCell;
        document.querySelector(`.cell[data-x="${x1}"][data-y="${y1}"]`)?.classList.remove('selected');

        const dx = Math.abs(x - x1);
        const dy = Math.abs(y - y1);
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
          // –û–±–º–µ–Ω
          [window.board[y][x], window.board[y1][x1]] = [window.board[y1][x1], window.board[y][x]];
          renderBoard();

          if (hasMatches()) {
            movesLeft--;
            movesEl.textContent = movesLeft;
            setTimeout(processTurn, 250);
            selectedCell = null;
            return;
          }

          // –û—Ç–∫–∞—Ç
          [window.board[y][x], window.board[y1][x1]] = [window.board[y1][x1], window.board[y][x]];
          renderBoard();
        }
        selectedCell = null;
      }

      if (movesLeft <= 0) {
        alert('–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å! –ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ".');
      }
    }

    function hasMatches() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE - 2; x++) {
          if (window.board[y][x] !== 'ü™®' &&
              window.board[y][x] === window.board[y][x+1] &&
              window.board[y][x] === window.board[y][x+2]) return true;
        }
      }
      for (let x = 0; x < BOARD_SIZE; x++) {
        for (let y = 0; y < BOARD_SIZE - 2; y++) {
          if (window.board[y][x] !== 'ü™®' &&
              window.board[y][x] === window.board[y+1][x] &&
              window.board[y][x] === window.board[y+2][x]) return true;
        }
      }
      return false;
    }

    function processTurn() {
      const toRemove = new Set();

      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE - 2; x++) {
          if (window.board[y][x] !== 'ü™®' &&
              window.board[y][x] === window.board[y][x+1] &&
              window.board[y][x] === window.board[y][x+2]) {
            let end = x + 2;
            while (end + 1 < BOARD_SIZE && window.board[y][end + 1] === window.board[y][x]) end++;
            for (let i = x; i <= end; i++) toRemove.add(`${i},${y}`);
            x = end;
          }
        }
      }

      // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
      for (let x = 0; x < BOARD_SIZE; x++) {
        for (let y = 0; y < BOARD_SIZE - 2; y++) {
          if (window.board[y][x] !== 'ü™®' &&
              window.board[y][x] === window.board[y+1][x] &&
              window.board[y][x] === window.board[y+2][x]) {
            let end = y + 2;
            while (end + 1 < BOARD_SIZE && window.board[end + 1][x] === window.board[y][x]) end++;
            for (let i = y; i <= end; i++) toRemove.add(`${x},${i}`);
            y = end;
          }
        }
      }

      let removed = 0;
      toRemove.forEach(pos => {
        const [x, y] = pos.split(',').map(Number);
        if (window.board[y][x] !== 'ü™®') {
          window.board[y][x] = null;
          removed++;
        }
      });

      collected += removed;
      collectedEl.textContent = collected;
      const target = TARGETS[currentLevel - 1] || TARGETS[TARGETS.length - 1];
      if (collected >= target) {
        completeLevel();
        return;
      }

      // –ü–∞–¥–µ–Ω–∏–µ
      for (let x = 0; x < BOARD_SIZE; x++) {
        let writeY = BOARD_SIZE - 1;
        for (let y = BOARD_SIZE - 1; y >= 0; y--) {
          if (window.board[y][x] !== null && window.board[y][x] !== 'ü™®') {
            if (writeY !== y) {
              window.board[writeY][x] = window.board[y][x];
              window.board[y][x] = null;
            }
            writeY--;
          }
        }
        for (let y = writeY; y >= 0; y--) {
          if (window.board[y][x] === null) {
            window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
          }
        }
      }

      renderBoard();
      if (hasMatches()) {
        setTimeout(processTurn, 250);
      }
    }

    function completeLevel() {
      gameActive = false;
      if (currentLevel < TOTAL_LEVELS && !unlockedLevels.includes(currentLevel + 1)) {
        unlockedLevels.push(currentLevel + 1);
        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels));
      }
      showScreen('win-screen');
    }

    // ====== –ù–ê–í–ò–ì–ê–¶–ò–Ø ======
    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    restartBtn.onclick = () => startLevel(currentLevel);
    btnNext.onclick = () => startLevel(currentLevel + 1);
    btnMap.onclick = () => {
      showScreen('map-screen');
      drawMazeMap();
    };

    // –°—Ç–∞—Ä—Ç
    drawMazeMap();
  </script>
</body>
</html>
