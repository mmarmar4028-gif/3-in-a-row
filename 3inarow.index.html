<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>–ö–æ–Ω—Ñ–µ—Ç–Ω—ã–π –õ–∞–±–∏—Ä–∏–Ω—Ç</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #fafafa;
      font-family: 'Segoe UI', system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 12px;
    }

    #app {
      width: 100%;
      max-width: 420px;
    }

    /* ========== –ò–ì–†–û–í–û–ô –≠–ö–†–ê–ù ========== */
    #game-ui {
      display: flex;
      justify-content: space-between;
      color: #d62828;
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 15px;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      background: #f0f0f0;
      padding: 4px;
      border-radius: 10px;
      aspect-ratio: 1 / 1;
      width: 100%;
    }

    .cell {
      background: white;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      cursor: pointer;
      transition: transform 0.12s;
    }

    .cell.obstacle {
      background: #555;
      color: white;
    }

    .cell.selected {
      transform: scale(0.88);
      box-shadow: 0 0 0 3px #e63946;
    }

    #instructions {
      background: #fff8f8;
      border-left: 3px solid #e63946;
      padding: 8px 10px;
      font-size: 13px;
      color: #555;
      margin-top: 10px;
      border-radius: 0 6px 6px 0;
    }

    #restart-btn {
      margin-top: 12px;
      width: 100%;
      padding: 10px;
      background: #e63946;
      color: white;
      border: none;
      border-radius: 30px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(230, 57, 70, 0.4);
    }

    /* ========== –≠–ö–†–ê–ù –ü–û–ë–ï–î–´ ========== */
    .screen { display: none; }
    .screen.active { display: block; }

    #win-screen {
      text-align: center;
      padding: 20px;
    }

    #win-screen h2 {
      color: #2e7d32;
      margin-bottom: 14px;
      font-size: 21px;
    }

    .coins {
      font-size: 26px;
      margin: 10px 0;
      color: #ffd700;
    }

    .btn {
      display: block;
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: none;
      border-radius: 30px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
    }

    .btn-next { background: #4caf50; color: white; }
    .btn-restart { background: #e63946; color: white; }
  </style>
</head>
<body>
  <div id="app">
    <!-- –ò–ì–†–û–í–û–ô –≠–ö–†–ê–ù -->
    <div id="game-screen" class="screen active">
      <div id="game-ui">
        <div><span id="target-type">üç´</span>: <span id="collected">0</span>/<span id="target">30</span></div>
        <div>–•–æ–¥—ã: <span id="moves">45</span></div>
        <div>–£—Ä: <span id="level-num">1</span></div>
      </div>
      <div id="game-board"></div>
      <div id="instructions">
        –°–æ–±–µ—Ä–∏ –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∫–∞–∑–∞–Ω–Ω–æ–π –∫–æ–Ω—Ñ–µ—Ç–∫–∏!<br>
        –û–±–º–µ–Ω–∏–≤–∞–π —Å–æ—Å–µ–¥–Ω–∏–µ –∫–æ–Ω—Ñ–µ—Ç–∫–∏, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ä—è–¥—ã –∏–∑ 3+.
      </div>
      <button id="restart-btn">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>

    <!-- –≠–ö–†–ê–ù –ü–û–ë–ï–î–´ -->
    <div id="win-screen" class="screen">
      <h2>üéâ –£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
      <div class="coins">ü™ôü™ôü™ôü™ôü™ô</div>
      <p>+5 –º–æ–Ω–µ—Ç–æ–∫ –∑–∞ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ!</p>
      <button class="btn btn-next" id="btn-next">‚ñ∂ –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
      <button class="btn btn-restart" id="btn-restart">üîô –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>
  </div>

  <script>
    // ====== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ======
    const CANDIES = ['üç≠', 'üç¨', 'üç´', 'üç©', 'üç™', 'üßÅ'];
    const LEVELS_CONFIG = [
      { target: 30, type: 'üç´', name: '—à–æ–∫–æ–ª–∞–¥–∫–∏' },
      { target: 40, type: 'üç≠', name: '–ª–µ–¥–µ–Ω—Ü—ã' },
      { target: 50, type: 'üç¨', name: '–∫–æ–Ω—Ñ–µ—Ç—ã' },
      { target: 60, type: 'üç©', name: '–ø–æ–Ω—á–∏–∫–∏' },
      { target: 70, type: null, name: '–ª—é–±—ã–µ –∫–æ–Ω—Ñ–µ—Ç—ã' },
      { target: 75, type: null, name: '–ª—é–±—ã–µ –∫–æ–Ω—Ñ–µ—Ç—ã' },
      { target: 80, type: null, name: '–ª—é–±—ã–µ –∫–æ–Ω—Ñ–µ—Ç—ã' },
      { target: 85, type: null, name: '–ª—é–±—ã–µ –∫–æ–Ω—Ñ–µ—Ç—ã' },
      { target: 90, type: null, name: '–ª—é–±—ã–µ –∫–æ–Ω—Ñ–µ—Ç—ã' },
      { target: 95, type: null, name: '–ª—é–±—ã–µ –∫–æ–Ω—Ñ–µ—Ç—ã' }
    ];
    const MOVES = 45;
    const BOARD_SIZE = 8;
    const TOTAL_LEVELS = LEVELS_CONFIG.length;

    // ====== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ======
    let currentLevel = 1;
    let collected = 0;
    let movesLeft = MOVES;
    let selectedCell = null;
    let gameActive = true;

    // ====== DOM ======
    const gameBoardEl = document.getElementById('game-board');
    const collectedEl = document.getElementById('collected');
    const targetEl = document.getElementById('target');
    const targetTypeEl = document.getElementById('target-type');
    const movesEl = document.getElementById('moves');
    const levelNumEl = document.getElementById('level-num');
    const instructionsEl = document.getElementById('instructions');
    const restartBtn = document.getElementById('restart-btn');
    const btnNext = document.getElementById('btn-next');
    const btnRestart = document.getElementById('btn-restart');

    // ====== –ü–û–ö–ê–ó –≠–ö–†–ê–ù–ê ======
    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    // ====== –ó–ê–ü–£–°–ö –£–†–û–í–ù–Ø ======
    function startLevel(level) {
      currentLevel = level;
      const cfg = LEVELS_CONFIG[level - 1];
      collected = 0;
      movesLeft = MOVES;

      collectedEl.textContent = '0';
      targetEl.textContent = cfg.target;
      targetTypeEl.textContent = cfg.type || 'üç¨';
      movesEl.textContent = movesLeft;
      levelNumEl.textContent = level;
      instructionsEl.innerHTML = `–°–æ–±–µ—Ä–∏ <b>${cfg.target}</b> ${cfg.name}!`;

      initBoard();
      showScreen('game-screen');
    }

    // ====== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –î–û–°–ö–ò ======
    function initBoard() {
      window.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));

      if (currentLevel >= 5) {
        const stoneCount = 2 * (currentLevel - 4);
        const positions = [];
        for (let y = 1; y < BOARD_SIZE - 1; y += 2) {
          for (let x = 1; x < BOARD_SIZE - 1; x += 2) {
            if (positions.length < stoneCount) positions.push([x, y]);
          }
        }
        for (const [x, y] of positions) {
          window.board[y][x] = 'ü™®';
        }
      }

      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (window.board[y][x] !== 'ü™®') {
            window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
          }
        }
      }

      while (hasMatches()) {
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (window.board[y][x] !== 'ü™®') {
              window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
            }
          }
        }
      }

      renderBoard();
    }

    function renderBoard() {
      gameBoardEl.innerHTML = '';
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (window.board[y][x] === 'ü™®') {
            cell.classList.add('obstacle');
            cell.textContent = 'ü™®';
          } else {
            cell.textContent = window.board[y][x];
          }
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleCellClick);
          gameBoardEl.appendChild(cell);
        }
      }
    }

    // ====== –û–ë–†–ê–ë–û–¢–ö–ê –ö–õ–ò–ö–û–í ======
    function handleCellClick(e) {
      if (!gameActive) return;
      const x = +e.target.dataset.x;
      const y = +e.target.dataset.y;
      if (window.board[y][x] === 'ü™®') return;

      if (selectedCell === null) {
        selectedCell = { x, y };
        e.target.classList.add('selected');
      } else {
        const { x: x1, y: y1 } = selectedCell;
        document.querySelector(`.cell[data-x="${x1}"][data-y="${y1}"]`)?.classList.remove('selected');

        const dx = Math.abs(x - x1);
        const dy = Math.abs(y - y1);
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
          const item1 = window.board[y1][x1];
          const item2 = window.board[y][x];

          window.board[y][x] = item1;
          window.board[y1][x1] = item2;
          renderBoard();

          let shouldConsumeMove = true;

          if (['üí£', '‚û°Ô∏è', '‚¨áÔ∏è', '‚ú®'].includes(item1) || ['üí£', '‚û°Ô∏è', '‚¨áÔ∏è', '‚ú®'].includes(item2)) {
            shouldConsumeMove = activateSpecial(x, y, x1, y1);
          }

          if (hasMatches()) {
            if (shouldConsumeMove) {
              movesLeft--;
              movesEl.textContent = movesLeft;
            }
            setTimeout(processTurn, 300);
            selectedCell = null;
            return;
          }

          if (shouldConsumeMove) {
            window.board[y][x] = item2;
            window.board[y1][x1] = item1;
            renderBoard();
          }
        }
        selectedCell = null;
      }

      if (movesLeft <= 0) {
        alert('–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å! –ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ".');
      }
    }

    // ====== –°–ü–ï–¶. –≠–õ–ï–ú–ï–ù–¢–´ ======
    function activateSpecial(x, y, x1, y1) {
      const a = window.board[y][x];
      const b = window.board[y1][x1];

      if (a === '‚ú®' || b === '‚ú®') {
        const other = a === '‚ú®' ? b : a;
        if (CANDIES.includes(other)) {
          let count = 0;
          for (let yy = 0; yy < BOARD_SIZE; yy++) {
            for (let xx = 0; xx < BOARD_SIZE; xx++) {
              if (window.board[yy][xx] === other) {
                window.board[yy][xx] = null;
                count++;
              }
            }
          }
          addCollected(count, other);
        }
        window.board[a === '‚ú®' ? y : y1][a === '‚ú®' ? x : x1] = null;
        return true;
      }

      if (a === 'üí£') {
        explodeArea(x, y);
        window.board[y][x] = null;
        return true;
      }
      if (b === 'üí£') {
        explodeArea(x1, y1);
        window.board[y1][x1] = null;
        return true;
      }

      if (a === '‚û°Ô∏è') {
        explodeRow(y);
        window.board[y][x] = null;
        return true;
      }
      if (a === '‚¨áÔ∏è') {
        explodeColumn(x);
        window.board[y][x] = null;
        return true;
      }
      if (b === '‚û°Ô∏è') {
        explodeRow(y1);
        window.board[y1][x1] = null;
        return true;
      }
      if (b === '‚¨áÔ∏è') {
        explodeColumn(x1);
        window.board[y1][x1] = null;
        return true;
      }

      return false;
    }

    function explodeArea(cx, cy) {
      let count = 0;
      const targetType = LEVELS_CONFIG[currentLevel - 1].type;
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          const x = cx + dx;
          const y = cy + dy;
          if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && window.board[y][x] !== 'ü™®') {
            if (window.board[y][x] !== null) {
              if (targetType === null || window.board[y][x] === targetType) {
                count++;
              }
              window.board[y][x] = null;
            }
          }
        }
      }
      addCollected(count, targetType);
    }

    function explodeRow(row) {
      let count = 0;
      const targetType = LEVELS_CONFIG[currentLevel - 1].type;
      for (let x = 0; x < BOARD_SIZE; x++) {
        if (window.board[row][x] !== 'ü™®' && window.board[row][x] !== null) {
          if (targetType === null || window.board[row][x] === targetType) {
            count++;
          }
          window.board[row][x] = null;
        }
      }
      addCollected(count, targetType);
    }

    function explodeColumn(col) {
      let count = 0;
      const targetType = LEVELS_CONFIG[currentLevel - 1].type;
      for (let y = 0; y < BOARD_SIZE; y++) {
        if (window.board[y][col] !== 'ü™®' && window.board[y][col] !== null) {
          if (targetType === null || window.board[y][col] === targetType) {
            count++;
          }
          window.board[y][col] = null;
        }
      }
      addCollected(count, targetType);
    }

    function addCollected(count, type) {
      const cfg = LEVELS_CONFIG[currentLevel - 1];
      if (cfg.type === null || type === cfg.type) {
        collected += count;
        collectedEl.textContent = collected;
        if (collected >= cfg.target) {
          completeLevel();
        }
      }
    }

    // ====== –ú–ï–•–ê–ù–ò–ö–ê –ò–ì–†–´ ======
    function hasMatches() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE - 2; x++) {
          if (window.board[y][x] !== 'ü™®' && window.board[y][x] === window.board[y][x+1] && window.board[y][x] === window.board[y][x+2]) {
            return true;
          }
        }
      }
      for (let x = 0; x < BOARD_SIZE; x++) {
        for (let y = 0; y < BOARD_SIZE - 2; y++) {
          if (window.board[y][x] !== 'ü™®' && window.board[y][x] === window.board[y+1][x] && window.board[y][x] === window.board[y+2][x]) {
            return true;
          }
        }
      }
      return false;
    }

    function findMatches() {
      const matches = [];
      for (let y = 0; y < BOARD_SIZE; y++) {
        let count = 1;
        let start = 0;
        for (let x = 1; x < BOARD_SIZE; x++) {
          if (window.board[y][x] !== 'ü™®' && window.board[y][x] === window.board[y][x-1]) {
            count++;
          } else {
            if (count >= 3) matches.push({ start: [start, y], end: [x-1, y], dir: 'h', count });
            count = 1;
            start = x;
          }
        }
        if (count >= 3) matches.push({ start: [start, y], end: [BOARD_SIZE-1, y], dir: 'h', count });
      }
      for (let x = 0; x < BOARD_SIZE; x++) {
        let count = 1;
        let start = 0;
        for (let y = 1; y < BOARD_SIZE; y++) {
          if (window.board[y][x] !== 'ü™®' && window.board[y][x] === window.board[y-1][x]) {
            count++;
          } else {
            if (count >= 3) matches.push({ start: [x, start], end: [x, y-1], dir: 'v', count });
            count = 1;
            start = y;
          }
        }
        if (count >= 3) matches.push({ start: [x, start], end: [x, BOARD_SIZE-1], dir: 'v', count });
      }
      return matches;
    }

    function findSquares() {
      const squares = [];
      for (let y = 0; y < BOARD_SIZE - 1; y++) {
        for (let x = 0; x < BOARD_SIZE - 1; x++) {
          if (window.board[y][x] !== 'ü™®' &&
              window.board[y][x] === window.board[y][x+1] &&
              window.board[y][x] === window.board[y+1][x] &&
              window.board[y][x] === window.board[y+1][x+1]) {
            squares.push({ x, y, candy: window.board[y][x] });
          }
        }
      }
      return squares;
    }

    function processTurn() {
      const matches = findMatches();
      const squares = findSquares();
      const toRemove = new Set();

      for (const m of matches) {
        const [sx, sy] = m.start;
        const [ex, ey] = m.end;
        if (m.dir === 'h') {
          for (let x = sx; x <= ex; x++) toRemove.add(`${x},${sy}`);
        } else {
          for (let y = sy; y <= ey; y++) toRemove.add(`${sx},${y}`);
        }
      }

      for (const sq of squares) {
        const keys = [`${sq.x},${sq.y}`, `${sq.x+1},${sq.y}`, `${sq.x},${sq.y+1}`, `${sq.x+1},${sq.y+1}`];
        keys.forEach(k => toRemove.delete(k));
        window.board[sq.y][sq.x] = 'üí£';
      }

      for (const m of matches) {
        if (m.count === 4) {
          const midX = Math.floor((m.start[0] + m.end[0]) / 2);
          const midY = Math.floor((m.start[1] + m.end[1]) / 2);
          toRemove.delete(`${midX},${midY}`);
          window.board[midY][midX] = m.dir === 'h' ? '‚û°Ô∏è' : '‚¨áÔ∏è';
        }
      }

      for (const m of matches) {
        if (m.count >= 5) {
          const midX = Math.floor((m.start[0] + m.end[0]) / 2);
          const midY = Math.floor((m.start[1] + m.end[1]) / 2);
          toRemove.delete(`${midX},${midY}`);
          window.board[midY][midX] = '‚ú®';
        }
      }

      let count = 0;
      const targetType = LEVELS_CONFIG[currentLevel - 1].type;
      toRemove.forEach(pos => {
        const [x, y] = pos.split(',').map(Number);
        if (window.board[y][x] !== 'ü™®') {
          if (targetType === null || window.board[y][x] === targetType) {
            count++;
          }
          window.board[y][x] = null;
        }
      });

      collected += count;
      collectedEl.textContent = collected;
      if (collected >= LEVELS_CONFIG[currentLevel - 1].target) {
        completeLevel();
        return;
      }

      for (let x = 0; x < BOARD_SIZE; x++) {
        let writeY = BOARD_SIZE - 1;
        for (let y = BOARD_SIZE - 1; y >= 0; y--) {
          if (window.board[y][x] !== null && window.board[y][x] !== 'ü™®') {
            if (writeY !== y) {
              window.board[writeY][x] = window.board[y][x];
              window.board[y][x] = null;
            }
            writeY--;
          }
        }
        for (let y = writeY; y >= 0; y--) {
          if (window.board[y][x] === null) {
            window.board[y][x] = CANDIES[Math.floor(Math.random() * CANDIES.length)];
          }
        }
      }

      renderBoard();
      if (hasMatches()) {
        setTimeout(processTurn, 300);
      }
    }

    // ====== –ó–ê–í–ï–†–®–ï–ù–ò–ï –£–†–û–í–ù–Ø ======
    function completeLevel() {
      gameActive = false;
      showScreen('win-screen');
    }

    // ====== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–ù–û–ü–û–ö ======
    restartBtn.onclick = () => startLevel(currentLevel);
    btnNext.onclick = () => {
      if (currentLevel < TOTAL_LEVELS) {
        startLevel(currentLevel + 1);
      } else {
        alert('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏!');
        startLevel(1); // –∏–ª–∏ –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–º
      }
    };
    btnRestart.onclick = () => startLevel(currentLevel);

    // ====== –°–¢–ê–†–¢ –ò–ì–†–´ ======
    startLevel(1);
  </script>
</body>
</html>
