<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>3 –≤ —Ä—è–¥: –ú–æ–Ω–µ—Ç–∫–∏</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
    }

    #app {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      width: 100%;
      max-width: 400px;
    }

    #ui {
      width: 100%;
      display: flex;
      justify-content: space-between;
      color: #c00;
      font-weight: bold;
      font-size: 18px;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      background: #e0e0e0;
      padding: 4px;
      border-radius: 8px;
      width: 100%;
      aspect-ratio: 1 / 1;
    }

    .cell {
      background: white;
      border-radius: 6px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
      position: relative;
    }

    .cell.coin::before {
      content: "ü™ô";
      font-size: 24px;
    }

    .cell.bomb::before {
      content: "üí£";
      font-size: 20px;
    }

    .cell.arrow-h::before,
    .cell.arrow-v::before {
      content: "‚û°Ô∏è";
      font-size: 20px;
    }

    .cell.arrow-v::before {
      content: "‚¨áÔ∏è";
    }

    .cell.rainbow::before {
      content: "üåü";
      font-size: 20px;
    }

    .cell.selected {
      transform: scale(0.92);
      box-shadow: 0 0 0 2px #e63946;
    }

    #restart-btn {
      background: #e63946;
      color: white;
      border: none;
      border-radius: 24px;
      padding: 10px 24px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(230, 57, 70, 0.4);
      transition: background 0.2s;
    }

    #restart-btn:hover {
      background: #d90429;
    }

    .cell.matched {
      opacity: 0.3;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="ui">
      <div>–•–æ–¥—ã: <span id="moves">30</span></div>
      <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
    </div>
    <div id="game-board"></div>
    <button id="restart-btn">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  </div>

  <script>
    const COLORS = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
    const BOARD_SIZE = 8;
    const INITIAL_MOVES = 30;

    let board = [];
    let movesLeft = INITIAL_MOVES;
    let level = 1;
    let selectedCell = null;
    let gameActive = true;

    const boardEl = document.getElementById('game-board');
    const movesEl = document.getElementById('moves');
    const levelEl = document.getElementById('level');
    const restartBtn = document.getElementById('restart-btn');

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–æ—Å–∫–∏
    function initBoard() {
      board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
      fillBoard();
      while (hasMatches()) {
        removeMatches();
        dropCoins();
        fillBoard();
      }
      renderBoard();
    }

    // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–æ—Å–∫–∏ —Å–ª—É—á–∞–π–Ω—ã–º–∏ –º–æ–Ω–µ—Ç–∫–∞–º–∏
    function fillBoard() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === null) {
            board[y][x] = { type: 'coin', color: COLORS[Math.floor(Math.random() * COLORS.length)] };
          }
        }
      }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
    function hasMatches() {
      const matches = findMatches();
      return matches.length > 0;
    }

    // –ü–æ–∏—Å–∫ –≤—Å–µ—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    function findMatches() {
      const matches = [];

      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
      for (let y = 0; y < BOARD_SIZE; y++) {
        let count = 1;
        let currentColor = board[y][0]?.color;
        let start = 0;
        for (let x = 1; x < BOARD_SIZE; x++) {
          if (board[y][x]?.color === currentColor && board[y][x]?.type === 'coin') {
            count++;
          } else {
            if (count >= 3) {
              matches.push({ start: [start, y], end: [x - 1, y], dir: 'h', count });
            }
            count = 1;
            start = x;
            currentColor = board[y][x]?.color;
          }
        }
        if (count >= 3) {
          matches.push({ start: [start, y], end: [BOARD_SIZE - 1, y], dir: 'h', count });
        }
      }

      // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
      for (let x = 0; x < BOARD_SIZE; x++) {
        let count = 1;
        let currentColor = board[0][x]?.color;
        let start = 0;
        for (let y = 1; y < BOARD_SIZE; y++) {
          if (board[y][x]?.color === currentColor && board[y][x]?.type === 'coin') {
            count++;
          } else {
            if (count >= 3) {
              matches.push({ start: [x, start], end: [x, y - 1], dir: 'v', count });
            }
            count = 1;
            start = y;
            currentColor = board[y][x]?.color;
          }
        }
        if (count >= 3) {
          matches.push({ start: [x, start], end: [x, BOARD_SIZE - 1], dir: 'v', count });
        }
      }

      return matches;
    }

    // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ 2x2
    function findSquares() {
      const squares = [];
      for (let y = 0; y < BOARD_SIZE - 1; y++) {
        for (let x = 0; x < BOARD_SIZE - 1; x++) {
          const c = board[y][x]?.color;
          if (
            c &&
            board[y][x + 1]?.color === c &&
            board[y + 1][x]?.color === c &&
            board[y + 1][x + 1]?.color === c &&
            board[y][x].type === 'coin' &&
            board[y][x + 1].type === 'coin' &&
            board[y + 1][x].type === 'coin' &&
            board[y + 1][x + 1].type === 'coin'
          ) {
            squares.push({ x, y, color: c });
          }
        }
      }
      return squares;
    }

    // –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –∏ —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ø–µ—Ü. —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    function removeMatches() {
      const matches = findMatches();
      const squares = findSquares();

      // –ú–∞—Ä–∫–∏—Ä—É–µ–º –≤—Å–µ —Å–æ–≤–ø–∞–¥–∞—é—â–∏–µ –∫–∞–∫ —É–¥–∞–ª—ë–Ω–Ω—ã–µ
      const toRemove = new Set();
      for (const match of matches) {
        const [sx, sy] = match.start;
        const [ex, ey] = match.end;
        if (match.dir === 'h') {
          for (let x = sx; x <= ex; x++) toRemove.add(`${x},${sy}`);
        } else {
          for (let y = sy; y <= ey; y++) toRemove.add(`${sx},${y}`);
        }
      }

      // –£–±–∏—Ä–∞–µ–º –∫–≤–∞–¥—Ä–∞—Ç—ã –∏–∑ –æ–±—â–µ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è (–æ–Ω–∏ —Å—Ç–∞–Ω—É—Ç –±–æ–º–±–∞–º–∏)
      for (const sq of squares) {
        const cells = [
          `${sq.x},${sq.y}`,
          `${sq.x + 1},${sq.y}`,
          `${sq.x},${sq.y + 1}`,
          `${sq.x + 1},${sq.y + 1}`
        ];
        cells.forEach(c => toRemove.delete(c));
        // –°–æ–∑–¥–∞—ë–º –±–æ–º–±—É –Ω–∞ –º–µ—Å—Ç–µ –∫–≤–∞–¥—Ä–∞—Ç–∞
        board[sq.y][sq.x] = { type: 'bomb', color: sq.color };
      }

      // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–æ–∫ (4 –≤ —Ä—è–¥)
      for (const match of matches) {
        if (match.count === 4) {
          const [sx, sy] = match.start;
          const [ex, ey] = match.end;
          const midX = Math.floor((sx + ex) / 2);
          const midY = Math.floor((sy + ey) / 2);
          toRemove.delete(`${midX},${midY}`);
          board[midY][midX] = {
            type: match.dir === 'h' ? 'arrow-h' : 'arrow-v',
            color: board[sy][sx]?.color
          };
        }
      }

      // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞–¥—É–∂–Ω–æ–π –º–æ–Ω–µ—Ç–∫–∏ (5+)
      for (const match of matches) {
        if (match.count >= 5) {
          const [sx, sy] = match.start;
          const [ex, ey] = match.end;
          const midX = Math.floor((sx + ex) / 2);
          const midY = Math.floor((sy + ey) / 2);
          toRemove.delete(`${midX},${midY}`);
          board[midY][midX] = { type: 'rainbow', color: null };
        }
      }

      // –£–¥–∞–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ
      toRemove.forEach(pos => {
        const [x, y] = pos.split(',').map(Number);
        board[y][x] = null;
      });
    }

    // –ü–∞–¥–µ–Ω–∏–µ –º–æ–Ω–µ—Ç–æ–∫
    function dropCoins() {
      for (let x = 0; x < BOARD_SIZE; x++) {
        let writeIndex = BOARD_SIZE - 1;
        for (let y = BOARD_SIZE - 1; y >= 0; y--) {
          if (board[y][x] !== null) {
            if (writeIndex !== y) {
              board[writeIndex][x] = board[y][x];
              board[y][x] = null;
            }
            writeIndex--;
          }
        }
      }
    }

    // –†–µ–Ω–¥–µ—Ä –¥–æ—Å–∫–∏
    function renderBoard() {
      boardEl.innerHTML = '';
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          const item = board[y][x];
          if (item) {
            cell.classList.add(item.type);
            if (item.color) cell.style.backgroundColor = item.color;
          }
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', () => handleCellClick(x, y));
          boardEl.appendChild(cell);
        }
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞
    function handleCellClick(x, y) {
      if (!gameActive) return;

      const cell = board[y][x];
      if (!cell) return;

      if (selectedCell === null) {
        selectedCell = { x, y };
        document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`).classList.add('selected');
      } else {
        const { x: x1, y: y1 } = selectedCell;
        document.querySelector(`.cell[data-x="${x1}"][data-y="${y1}"]`).classList.remove('selected');

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ—Å–µ–¥–Ω–∏–µ –ª–∏
        const dx = Math.abs(x - x1);
        const dy = Math.abs(y - y1);
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
          // –û–±–º–µ–Ω
          [board[y][x], board[y1][x1]] = [board[y1][x1], board[y][x]];
          renderBoard();

          if (hasMatches()) {
            movesLeft--;
            movesEl.textContent = movesLeft;
            processTurn();
          } else {
            // –û—Ç–∫–∞—Ç
            [board[y][x], board[y1][x1]] = [board[y1][x1], board[y][x]];
            renderBoard();
          }
        }
        selectedCell = null;
      }

      if (movesLeft <= 0) {
        gameActive = false;
        alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –£—Ä–æ–≤–µ–Ω—å: ${level}`);
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ö–æ–¥–∞: —É–¥–∞–ª–µ–Ω–∏–µ, –ø–∞–¥–µ–Ω–∏–µ, –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
    function processTurn() {
      setTimeout(() => {
        removeMatches();
        renderBoard();

        setTimeout(() => {
          dropCoins();
          fillBoard();
          renderBoard();

          if (hasMatches()) {
            setTimeout(processTurn, 300);
          } else if (movesLeft > 0) {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
            if (!hasAnyValidMove()) {
              fillBoard();
              renderBoard();
              if (hasMatches()) {
                setTimeout(processTurn, 300);
              }
            }
          }
        }, 300);
      }, 300);
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ–≥–æ –≤–∞–ª–∏–¥–Ω–æ–≥–æ —Ö–æ–¥–∞
    function hasAnyValidMove() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          // –í–ø—Ä–∞–≤–æ
          if (x < BOARD_SIZE - 1) {
            [board[y][x], board[y][x + 1]] = [board[y][x + 1], board[y][x]];
            const hasMatch = hasMatches();
            [board[y][x], board[y][x + 1]] = [board[y][x + 1], board[y][x]];
            if (hasMatch) return true;
          }
          // –í–Ω–∏–∑
          if (y < BOARD_SIZE - 1) {
            [board[y][x], board[y + 1][x]] = [board[y + 1][x], board[y][x]];
            const hasMatch = hasMatches();
            [board[y][x], board[y + 1][x]] = [board[y + 1][x], board[y][x]];
            if (hasMatch) return true;
          }
        }
      }
      return false;
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
    function startGame() {
      level = 1;
      movesLeft = INITIAL_MOVES;
      gameActive = true;
      selectedCell = null;
      levelEl.textContent = level;
      movesEl.textContent = movesLeft;
      initBoard();
    }

    restartBtn.addEventListener('click', startGame);
    startGame();
  </script>
</body>
</html>
